% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/dr_to_fcs.R
\name{dr_to_fcs}
\alias{dr_to_fcs}
\title{Calculate dimension reductions and cluster annotations with data from one or more flow frames and add these parameters to a (concanetated fcs file)}
\usage{
dr_to_fcs(
  ff.list,
  channels = NULL,
  add.sample.info,
  scale.whole = c("z.score", "min.max", "none"),
  scale.samples = c("none", "z.score", "min.max"),
  run.harmony = F,
  run.pca = F,
  run.lda = F,
  run.umap = T,
  run.tsne = F,
  run.som = T,
  run.gqtsom = T,
  run.louvain = T,
  run.kmeans = F,
  run.leiden = F,
  run.hclust = F,
  run.flowClust = F,
  run.MUDAN = F,
  n.pca.dims = 0,
  calc.cluster.markers = NULL,
  extra.cols,
  mc.cores = 1,
  save.to.disk = c("fcs", "rds"),
  save.path = file.path(getwd(), paste0(substr(gsub("\\\\.", "",
    make.names(as.character(Sys.time()))), 2, 15), "_FCS_dr")),
  exclude.extra.channels = ifelse(length(ff.list) == 1 && names(ff.list) == "logicle",
    "cluster.id", "FSC|SSC|Time|cluster.id"),
  write.scaled.channels.to.FCS = T,
  timeChannel = "Time",
  ...
)
}
\arguments{
\item{ff.list}{a list of flowFrames as received from fcexpr::wsp_get_ff (compensated with Compensation Matrix as defined in FlowJo by default) or
as received from fcexpr::inds_get_ff (directly from FCS files, not compensated by default)}

\item{channels}{a named vector of channels to use for dimension reduction. values can be channel names (v-450LP..., b-520..., or so), or channel descriptions (e.g. CD3 or LAG3-PeCy7 for example)
names will be used as new description in the fcs file to be written; if no names provided, names of the very first FCS file will be used}

\item{add.sample.info}{named list of additional channels to identify samples or group them in flowjo;
e.g.: add.sample.info = list(condition = c(1,2,3,1,2,3,1,2,3), donor = c(1,1,1,2,2,2,3,3,3))}

\item{scale.whole}{if and how to scale channels after concatenation of flowframes in ff.list}

\item{scale.samples}{if and how to scale channels of flowframes in ff.list individually before concatenation}

\item{run.harmony}{attempt batch correction using harmony::HarmonyMatrix; if TRUE, then harmony__meta_data has to be provided in ... indicating the groups to be batch corrected;
harmony is conducted before run.pca; to calculate a pca before harmony, pass harmony__do_pca = T and optional a number of pcs with harmony__npcs. Set run.pca = F
when a pca is calculated in harmony.}

\item{run.pca}{run principle component analysis before dimension reduction. may not be necessary when less than 10 or so are provided in channels.
on the other hand if you decide to pass all channels (including those without any actual staining), then pca will focus on the ones with highest variances.}

\item{run.lda}{run Linear Discriminant Analysis before dimension reduction;
should be F (FALSE) or a clustering calculated before, e.g. louvain_0.8 or leiden_1.1, kmeans_12 etc.; respective clustering calculation
has to be provided in ...}

\item{run.umap}{calculate UMAP dimension reduction with uwot::umap}

\item{run.tsne}{calculate tsne dimension reduction with Rtsne::Rtsne}

\item{run.som}{calculate SOM dimension reduction EmbedSOM::SOM followed by EmbedSOM::EmbedSOM}

\item{run.gqtsom}{calculate GQTSOM dimension reduction EmbedSOM::GQTSOM followed by EmbedSOM::EmbedSOM}

\item{run.louvain}{detect clusters (communities, groups) of cells with the louvain algorithm, implemented in Seurat::FindClusters (subsequent to snn detection by Seurat::FindNeighbors)}

\item{run.kmeans}{detect clusters with stats::kmeans; will be the quickest way to get cluster annotation!!!}

\item{run.leiden}{detect clusters (communities, groups) of cells with the leiden algorithm, with leiden::leiden (subsequent to snn detection by Seurat::FindNeighbors)}

\item{run.hclust}{detect clusters with stats::dist, stats::hclust and stats::cutree}

\item{run.flowClust}{detect clusters with flowClust::flowClust}

\item{run.MUDAN}{detect clusters with MUDAN::getComMembership (k = as.numeric(names(run.MUDAN))); e.g. run.MUDAN = setNames(TRUE, 8)}

\item{n.pca.dims}{number of principle components to calculate; generally, with 10 channels or less PCA may not be necessary to calculate;
e.g. if you choose only channel which do have an amount a variation (different populations) then PCA is not required; if you are lazy
and simply select all available channels, PCA will select the most relevant number of dimensions for you}

\item{calc.cluster.markers}{if NULL nothing is calculated; otherwise provide the clustering(s) for which cluster markers are to be determined,
using matrixStats::col_wilcoxon_twosample every cluster is compared to all other cells as well as all clusters pairwise.
respective clustering calculation has to be provided in ...; e.g. if louvain__resolution = 0.5 is provided set calc.cluster.markers = louvain_0.5;
and if in addition leiden__resolution_parameter = 0.7 then set calc.cluster.markers = c(louvain_0.5, leiden_0.7).}

\item{extra.cols}{vector of one extra column (or matrix of multiple columns) to add to the final fcs file;
has to be numeric; has to be equal to the number of rows of all flowframes provided; colnames of matrix dictate
channel names in the FCS file}

\item{mc.cores}{mc.cores to calculate clusterings, limited to parallel::detectCores()-1}

\item{save.to.disk}{what to save to disk: (concatenated) and appended FCS file and/or rds file with several elements in a list}

\item{save.path}{where to save elements specified in save.to.disk; set to NULL to have nothing written to disk}

\item{exclude.extra.channels}{when scaled and transform channels are written to FCS file, some channels may be redundant
and will only occupy disk space, those are specified here; matched with grepl}

\item{write.scaled.channels.to.FCS}{do save scaled channels (scale.whole, scale.samples) to FCS file}

\item{timeChannel}{name of the Time channel to exclude from all analyses and calculation; if NULL will be attempted
to be detected automatically}

\item{...}{additional parameters to calculations of UMAP, tSNE, som, gqtsom, EmbedSOM, louvain, leiden, harmony, hclust, flowClust, MUDAN, kmeans;
provide arguments as follows: UMAP__n_neighbors = c(15,20,25), or tsne__theta = 0.3, etc.
see respected help files to get to know which arguments can be passed:
uwot::umap, Rtsne::Rtsne, EmbedSOM::SOM, EmbedSOM::GQTSOM, EmbedSOM::EmbedSOM, harmony::HarmonyMatrix, flowClust::flowClust,
louvain: Seurat::FindNeighbors and Seurat::FindCluster, leiden: Seurat::FindNeighbors and leiden::leiden.
hclust: stats::dist and stats::hclust, MUDAN: MUDAN::getComMembership, stats::kmeans}
}
\value{

}
\description{
Calculate dimension reductions and cluster annotations with data from one or more flow frames and add these parameters to a (concanetated fcs file)
}
\details{
logicle trans: 2006 - Parks_A New Logicle Display Method Avoids Deceptive Effects of Logarithmic Scaling for Low Signals and Compensated Data
}
\examples{

########################################
### Plot cluster markers with ggplot ###
########################################
dr <- fcexpr::dr_to_fcs(ff.list = ffs,
channels = channels,
louvain__resolution = 0.5,
run.lda = "louvain_0.5",
calc.cluster.markers = c("louvain_0.5"),
save.path = NULL)
marker <- dr[[3]][[1]][[1]]
marker$channel_desc2 <- sapply(strsplit(marker$channel_desc, "_"), "[", 1)
marker <-
 marker \%>\%
 dplyr::mutate(pvalue = ifelse(pvalue == 0, 1e-300, marker$pvalue))
dplyr::group_by(channel_desc2) \%>\%
 dplyr::mutate(mean_scaled = fcexpr:::min.max.normalization(mean))
ggplot(marker, aes(x = as.factor(cluster), y = channel_desc2, fill = -log10(pvalue))) +
 geom_tile(color = "black") +
 theme_bw() +
 geom_text(aes(label = diff_sign)) +
 scale_fill_viridis_c()
ggplot(marker, aes(x = as.factor(cluster), y = channel_desc2, fill = mean_diff)) +
 geom_tile(color = "black") +
 theme_bw() +
 geom_text(aes(label = diff_sign)) +
 scale_fill_viridis_c()
ggplot(marker, aes(x = as.factor(cluster), y = channel_desc2, fill = mean_scaled)) +
 geom_tile(color = "black") +
 theme_bw() +
 scale_fill_viridis_c()
ggplot(marker, aes(x = mean_diff, y = -log10(pvalue), label = channel_desc2)) + #color = channel_desc2,
 geom_point() +
 theme_bw() +
 labs(title = "cluster markers (vs all other cells each)") +
 ggrepel::geom_text_repel(max.overlaps = 20, show.legend = F) +
 theme(panel.grid.minor.x = element_blank(), panel.grid.minor.y = element_blank(), panel.grid.major.x = element_blank(), strip.background = element_rect(fill = "hotpink2")) +
 geom_vline(xintercept = 0, col = "tomato2", linetype = "dashed") +
 geom_hline(yintercept = 100, col = "tomato2", linetype = "dashed") +
 facet_wrap(vars(cluster))

}
